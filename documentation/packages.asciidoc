
:toc: 

= Packages

toc::[]

== Overview

Devon4Net is made up of several components, all of which are described in this document. This components are available in the form of NuGet packages. In the https://github.com/devonfw/devon4net[Devon4Net repository] this packages are placed in the Infrastructure layer which is a cross-cutting layer that can be referenced from any level on the architecture.

.Infrastructure directory
image::images/Infrastructure_package.png[]

Components are class librarys that collaborate with each other for a purpose. They group the necessary code so that they can work according to the specified configuration. For example, the package `Devon4Net.Infrastructure.Swagger` has isolated the swagger essential pieces of code and has been developed in such a manner that you just need to write a few lines and specify a couple options to get it working the way you need.

=== Component structure

All of the components follow a similar structure which includes the next directories:

* *Configuration:* Static configuration class (or multiple classes) that contains extension methods used to configure the component.
* *Handlers:* Classes that are required to manage complex operations or communications.
* *Helpers:* Normally static classes that help in small conversions and operations.
* *Constants:* Classes that contain static constants to get rid of hard-coded values.

NOTE: Because each component is unique, you may find some more directories or less than those listed above.

== Configuration basics

Any configuration for .Net Core 6.0 projects needs to be done in the `Program.cs` files which is placed on the startup application, but we can extract any configuration needed to an extension method and call that method from the component. As a result, the component will group everything required and the configuration will be much easier.

=== Extension methods

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods[Extension methods] allow you to "add" methods to existing types without having to create a new derived type, or modify it in any way. Although they are static methods, they are referred to as instance methods on the extended type. For C# code, there is no difference in calling a extension method and a method defined in a type.

For example, the next extension method will extend the class `ExtendedClass` and it will need an `OptionalParameter` instance to do some configuration:

[source, c#]
----
public static class ExtensionMethods
{
    public static void DoConfiguration(this ExtendedClass class,  OptionalParameter extra) 
    {
        // Do your configuration here
        class.DoSomething();
        class.AddSomething(extra)
    }
}
----

Thanks to the `this` modifier preceeding the first parameter, we are able to call the method directly on a instance of `ExtendedClass` as follows:

[source, c#]
----
ExtendedClass class = new();
OptionalParameter extra = new();

class.DoConfiguration(extra);
----

As you can see, we don't need that a class derived from `ExtendedClass` to add some methods and we don't need those methods placed in the class itself either. This can be seen easily when extending a primitive type such as `string`:

[source, c#]
----
public static class ExtensionMethods
{
    public static int CountWords(this string word,  char[] separationChar = null) 
    {
        if(separationChar == null) separationChar = new char[]{' '};
        return word.Split(separationChar, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}
----

In the previous example we created a method that can count words given a list of separation characters. And now we can use it over any string as follows:

[source, c#]
----
string s = "Hello World";
Console.WriteLine(s.CountWords());
----
[source, output]
----
2
----

NOTE: Remember to reference the class so you can use the extension methods (`using` directive).

=== Options pattern

The https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0[options design pattern] allows you to have strong typed options and provides you the ability to inject them into your services. To follow this pattern, the configuration present on the `appsettings.json` needs to be mapped into an object.

This means, the following configuration:
[source, json]
----
"essentialoptions" : {
  "value1": "Hello",
  "value2": "World"
}
----

Would need the following class:
[source, c#]
----
public class EssentialOptions 
{
    public string Value1 { get; set; }
    public string Value2 { get; set; }
}
----

In .Net we can easily map the configuration thanks to the `Configure<T>()` method from `IServiceCollection` and `GetSection()` method from `IConfiguration`. We could be loading the configuration as follows:

[source, c#]
----
services.Configure<EssentialOptions>(configuration.GetSection("essentialoptions"));
----

And then injecting it making use of `IOptions<T>` interface:
[source, c#]
----
public class MyService : IMyService
{
    private readonly EssentialOptions _options;

    public MyService(IOptions<EssentialOptions> options) 
    {
        _options = options.Value;
    }
}
----

In devon4net, there is an `IServiceCollection` extension available that uses the methods described above and also returns the options injected thanks to `IOptions<T>`.  So, to load the same options, we should use the following:

[source, c#]
----
EssentialOptions options = services.GetTypedOptions<EssentialOptions>(configuration, "essentialoptions");
----

=== Dependency Injection

https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection[Dependency Injection] is a technique for achieving Inversion of Control Principle. In .Net it is a built-in part that comes with the framework.

Using a service provider `IServiceProvider` available in .Net, we are able to add any service or option to a service stack that will be available for injection in constructors of the classes where it's used.

Services can be registered with one of the following lifetimes:
|=====
|*Lifetime* | *Description* |*Example*
|Transient |Transient lifetime services are created each time they're requested from the service container. Disposed at the end of the request. |services.AddTransient<IDependency, Dependency>();
|Scoped |A scoped lifetime indicates that services are created once per client request (connection).  Disposed at the end of the request. |services.AddScoped<IDependency, Dependency>();
|Singleton |Singleton lifetime services are created either the first time they're requested or by the developer. Every subsequent request of the service implementation from the dependency injection container uses the same instance. |services.AddSingleton<IDependency, Dependency>();
|=====

This injections would be done in the startup project in `Program.cs` file, and then injected in constructors where needed.

== Devon4Net.Infrastructure.CircuitBreaker

The Devon4Net.Infrastructure.CircuitBreaker component implements the retry pattern for HTTP/HTTPS calls. It may be used in both SOAP and REST services. 

=== Configuration

Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"CircuitBreaker": {
    "CheckCertificate": false,
    "Endpoints": [
      {
        "Name": "SampleService",
        "BaseAddress": "http://localhost:5001",
        "Headers": {
        },
        "WaitAndRetrySeconds": [
          0.0001,
          0.0005,
          0.001
        ],
        "DurationOfBreak": 0.0005,
        "UseCertificate": false,
        "Certificate": "localhost.pfx",
        "CertificatePassword": "localhost",
        "SslProtocol": "Tls12", //Tls, Tls11,Tls12, Tls13, none
        "CompressionSupport": true,
        "AllowAutoRedirect": true
      }
    ]
  }
----
[options="header"]
|=======================
|*Property*|*Description*
|`CheckCertificate`| True if HTTPS is required. This is useful when developing an API Gateway needs a secured HTTP, disabling this on development we can use communications with a valid server certificate
|Endpoints| Array with predefined sites to connect with
|Name| The name key to identify the destination URL
|Headers| Not ready yet
|WaitAndRetrySeconds| Array which determines the number of retries and the lapse period between each retry. The value is in milliseconds.
|Certificate| Ceritificate client to use to perform the HTTP call
|CertificatePassword| The password that you assign when exporting the certificate
|`SslProtocol`| The secure protocol to use on the call

|=======================

==== Protocols
[options="header"]
|=======================
|*Protocol*|*Key*|*Description*
|SSl3|48| Specifies the Secure Socket Layer (SSL) 3.0 security protocol. SSL 3.0 has been superseded by the Transport Layer Security (TLS) protocol and is provided for backward compatibility only.
|TLS|192|Specifies the Transport Layer Security (TLS) 1.0 security protocol. The TLS 1.0 protocol is defined in IETF RFC 2246.
|TLS11|768| Specifies the Transport Layer Security (TLS) 1.1 security protocol. The TLS 1.1 protocol is defined in IETF RFC 4346. On Windows systems, this value is supported starting with Windows 7.
|TLS12|3072| Specifies the Transport Layer Security (TLS) 1.2 security protocol. The TLS 1.2 protocol is defined in IETF RFC 5246. On Windows systems, this value is supported starting with Windows 7.
|TLS13|12288| Specifies the TLS 1.3 security protocol. The TLS protocol is defined in IETF RFC 8446.

|=======================

=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

Add it using Dependency Injection on this case we instanciate Circuit Breaker in a Service Sample Class

[source, C#]
----
public class SampleService: Service<SampleContext>, ISampleService
    {
        private readonly ISampleRepository _sampleRepository;
        private IHttpClientHandler _httpClientHandler { get; }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="uoW"></param>
        public SampleService(IUnitOfWork<SampleContext> uoW, IHttpClientHandler httpClientHandler) : base(uoW)
        {
            _httpClientHandler = httpClientHandler;
            _sampleRepository = uoW.Repository<ISampleRepository>();
        }
    }    
----

Add the necessary references. 

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker.Common.Enums;
using Devon4Net.Infrastructure.CircuitBreaker.Handlers;
----

You must give the following arguments to make a POST call:

[source, C#]
----
await _httpClientHandler.Send<YourOutPutClass>(HttpMethod.POST, NameOfTheService, EndPoint, InputData, MediaType.ApplicationJson);    
----

Where:

[options="header"]
|=======================
|*Property*|*Description*
|YourOutputClass| The type of the class that you are expecting to retrieve from the call 
|NameOftheService| The key name of the endpoint provided in the appsettings.json file at Endpoints[] node
|`EndPoint`|Part of the url to use with the base address. E.g: _/validate_
|`InputData`| Your instance of the class with values that you want to use in the call
|`MediaType.ApplicationJson`| The media type flag for the call
|=======================


=== Setting up in other projects

Install the package on your solution using the Package Manager Console:

[source]
----
Install-Package Devon4Net.Infrastructure.CircuitBreaker
----

next add via Dependency Injection the circuit breaker instance.On this case we use a Service

[source, C#]
----
public class SampleService : ISampleService
 {
   private IHttpClientHandler _httpClientHandler { get; }

    public SampleService(IHttpClientHandler httpClientHandler)
      {
        _httpClientHandler = httpClientHandler;
      }
 }
----

Don't forget to provide the necessary references. 

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker.Common.Enums;
using Devon4Net.Infrastructure.CircuitBreaker.Handlers;
----

And configure CircuitBreaker in `Program.cs` adding the following lines:

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker;
.
.
.
builder.Services.SetupCircuitBreaker(builder.Configuration);
----

You must add the default configuration shown in the configuration section and at this point you can use the circuit breaker functionality in your code.

To perform a GET call you should use your circuit breaker instance as follows:

[source, C#]
----
await _httpClientHandler.Send<YourOutPutClass>(HttpMethod.Get, NameOfTheService, EndPoint, InputData, MediaType.ApplicationJson);    
----

Where:

[options="header"]
|=======================
|*Property*|*Description*
|YourOutputClass| The type of the class that you are expecting to retrieve from the call 
|NameOftheService| The key name of the endpoint provided in the appsettings.json file at Endpoints[] node
|`EndPoint`|Part of the url to use with the base address. E.g: _/validate_
|`InputData`| Your instance of the class with values that you want to use in the call
|`MediaType.ApplicationJson`| The media type flag for the call
|=======================

== Devon4Net.Infrastructure.Swagger

Swagger is a set of open source software tools for designing, building, documenting, and using RESTful web services. This component provides a full externalized configuration for the Swagger tool. 

It primarily provides the swagger UI for visualizing and testing APIs, as well as automatic documentation generation via annotations in controllers.

=== Configuration

Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"Swagger": {
    "Version": "v1",
    "Title": "My Swagger API",
    "Description": "Swagger API for devon4net documentation",
    "Terms": "https://www.devonfw.com/terms-of-use/",
    "Contact": {
      "Name": "devonfw",
      "Email": "sample@mail.com",
      "Url": "https://www.devonfw.com"
    },
    "License": {
      "Name": "devonfw - Terms of Use",
      "Url": "https://www.devonfw.com/terms-of-use/"
    },
    "Endpoint": {
      "Name": "V1 Docs",
      "Url": "/swagger/v1/swagger.json",
      "UrlUi": "swagger",
      "RouteTemplate": "swagger/v1/{documentName}/swagger.json"
    }
},
----

In the following list all the configuration fields are described:

* `Version`: Actual version of the API.
* `Title`: Title of the API.
* `Description`: Description of the API.
* `Terms`: Link to the terms and conditions agreement.
* `Contact`: Your contact information.
* `License`: Link to the License agreement.
* `Endpoint`: Swagger endpoints information.

=== Setting up in Devon
For setting it up using the Devon4NetApi template just configure it in the `appsettings.{environment}.json` file.


=== Setting up in other projects
Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.Swagger
----

Configure swagger in `Program.cs` adding the following lines:

[source, c#]
----
using Devon4Net.Infrastructure.Swagger;
.
.
.
builder.Services.SetupSwagger(builder.Configuration);
.
.
.
app.ConfigureSwaggerEndPoint();
----

Add the default configuration shown in the configuration section.

=== Tips

* In order to generate the documentation annotate your actions with summary, remarks and response tags:
[source, c#]
----
/// <summary>
/// Method to make a reservation with potential guests. The method returns the reservation token.
/// </summary>
/// <param name="bookingDto"></param>
/// <response code="201">Ok.</response>
/// <response code="400">Bad request. Parser data error.</response>
/// <response code="401">Unauthorized. Authentication fail.</response>
/// <response code="403">Forbidden. Authorization error.</response>
/// <response code="500">Internal Server Error. The search process ended with error.</response>
[HttpPost]
[HttpOptions]
[Route("/mythaistar/services/rest/bookingmanagement/v1/booking")]
[AllowAnonymous]
[EnableCors("CorsPolicy")]
public async Task<IActionResult> Booking([FromBody]BookingDto bookingDto)
{
    try
    {

    ...
----
* You can access the swagger UI on `http://localhost:yourport/swagger/index.html`

== Devon4Net.Infrastructure.Logger

Previously known as Devon4Net.Infrastructure.Log(v5.0 or lower)

Logging is an essential component of every application's life cycle.
A strong logging system becomes a critical component that assists developers to understand and resolve emerging problems. 

NOTE: Starting with .NET 6, logging services no longer register the ILogger type. When using a logger, specify the generic-type alternative ILogger<TCategoryName> or register the `ILogger` with dependency injection (DI).

Default .Net log levels system: 

|=======================
|*Type*|*Description*
|Critical| Used to notify failures that force the program to shut down  
|Error| Used to track major faults that occur during program execution 
|Warning| Used to report non-critical unexpected behavior
|Information| Informative messages
|Debug| Used for debugging messages containing additional information about application operations 
|Trace| For tracing the code
|None| If you choose this option the loggin category will not write any messages
|=======================

=== Configuration

Component setup is done in the `appsettings.{environment}.json` file using the following structure:

[source, json]
----
  "Logging": {
    "UseLogFile": true,
    "UseSQLiteDb": true,
    "UseGraylog": true,
    "UseAOPTrace": false,
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    },
    "SqliteDatabase": "logs/log.db",
    "LogFile": "logs/{0}_devonfw.log",
    "SeqLogServerHost": "http://127.0.0.1:5341",
    "GrayLog": {
      "GrayLogHost": "127.0.0.1",
      "GrayLogPort": "12201",
      "GrayLogProtocol": "UDP",
      "UseSecureConnection": true,
      "UseAsyncLogging": true,
      "RetryCount": 5,
      "RetryIntervalMs": 15,
      "MaxUdpMessageSize": 8192
    }
  }
----

Where:

* `UseLogFile`: When you set this option to true, you can store the log output to a file.  
* `UseSQLiteDb`: True when you wish to insert the log output into a SQLiteDb
* `UseGrayLog`: This option enables the use of GrayLog for loggin
* `UseAOPTrace`: True if you need to trace the attributes of the controllers

WARNING: Don't set to true on production environments, doing so may expose critical information. 

* `LogLevel`: Sets the minimum level of logs to be captured
* `SqliteDatabase`: path to SQlite database 
* `LogFile`: path to the log file
* `SeqLogServerHost`: url for Seq server, you need to install Seq  in order to use it, you can install it clicking https://datalust.co/download[here]
* `GrayLog`: Some configuration parameters for Graylog service you can install it using https://www.graylog.org/products/open-source#download-open[this link] 


=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

You can use the methods implemented in Devon4NetLogger class, each method corresponds with a log level in .Net log levels system, for example:

[source, c#]
----
Devon4NetLogger.Debug("Executing GetTodo from controller TodoController");
----


=== Setting up in other projects

Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.Logger
----

Add the following line of code to Progam.cs: 

[source, c#]
----
builder.Services.SetupLog(builder.Configuration);
----

Add the default configuration shown in the configuration section.

use the Devon4NetLogger class methods as explanied above:

[source, c#]
----
Devon4NetLogger.Information("Executing GetSample from controller SampleController");
----


== Devon4Net.Infrastructure.Cors

Allows CORS settings for the devon4Net application.
Configuration may be used to configure several domains.
Web clients (for example, Angular) must follow this rule to avoid performing AJAX calls to another domain. 

Cross-Origin Resource Sharing (CORS) is an HTTP-header-based mechanism that allows a server to specify any origin (domain, scheme, or port) outside of its own from which a browser should allow resources to be loaded. CORS also makes use of a process in which browsers send a "preflight" request to the server hosting the cross-origin resource to ensure that the server will allow the actual request. During that preflight, the browser sends headers indicating the HTTP method as well as headers that will be used in the actual request.

You may find out more by going to https://docs.microsoft.com/es-es/aspnet/core/security/cors?view=aspnetcore-6.0[Microsoft CORS documentation]

=== Configuration

Component setup is done in the `appsettings.{environment}.json` file using the following structure:

[source, json]
----
 "Cors": //[], //Empty array allows all origins with the policy "CorsPolicy"
  [
    {
      "CorsPolicy": "CorsPolicy",
      "Origins": "http://localhost:4200,https://localhost:4200,http://localhost,https://localhost;http://localhost:8085,https://localhost:8085",
      "Headers": "accept,content-type,origin,x-custom-header,authorization",
      "Methods": "GET,POST,HEAD,PUT,DELETE",
      "AllowCredentials": true
    }
  ]
----

You may add as many policies as you like following the JSON format. for example:

[source, json]
----
 "Cors": //[], //Empty array allows all origins with the policy "CorsPolicy"
  [
    {
      "CorsPolicy": "FirstPolicy",
      "Origins": "http://localhost:4200",
      "Headers": "accept,content-type,origin,x-custom-header,authorization",
      "Methods": "GET,POST,DELETE",
      "AllowCredentials": true
    },
    {
      "CorsPolicy": "SecondPolicy",
      "Origins": "https://localhost:8085",
      "Headers": "accept,content-type,origin",
      "Methods": "GET,POST,HEAD,PUT,DELETE",
      "AllowCredentials": false
    }
  ]
----

In the following table all the configuration fields are described:

|=======================
|*Property*|*Description*
|CorsPolicy| Name of the policy
|Origins| The origin's url that you wish to accept.
|Headers| Permitted request headers
|Methods| Allowed Http methods
|AllowCredentials| Set true to allow the exchange of credentials across origins
|=======================

=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

You can enable CORS per action, per controller, or globally for all Web API controllers in your application:

* Add this annotation in the Controller Class you want to use CORS policy
+
[source, c#]
----
[EnableCors("CorsPolicy")]
----
+
As an example, consider this implementation on the EmployeeController class
+
[source, c#]
----
namespace Devon4Net.Application.WebAPI.Implementation.Business.EmployeeManagement.Controllers
{
    /// <summary>
    /// Employees controller
    /// </summary>
    [ApiController]
    [Route("[controller]")]
    [EnableCors("CorsPolicy")]
    public class EmployeeController: ControllerBase
    {
      .
      .
      .
    }
}
----
+
The example above enables CORS for all the controller methods.

* In the same way, you may enable CORS on any controller method:
+
[source, c#]
----
[EnableCors("FirstPolicy")]
public async Task<ActionResult> GetEmployee()
{

}
        
public async Task<ActionResult> ModifyEmployee(EmployeeDto employeeDto) 
{

}

[EnableCors("SecondPolicy")]        
public async Task<ActionResult> Delete([Required]long employeeId)
{

}
----
+
The example above enables CORS for the GetEmployee and Delete method. 

=== Setting up in other projects

Using the Package Manager Console, install the the next package on your solution: 

[source, console]
----
> install-package Devon4Net.Infrastructure.Cors
----

Add the following lines of code to Progam.cs: 

[source, c#]
----
builder.Services.SetupCors(builder.Configuration);
.
.
.
app.SetupCors();
----

Add the default configuration shown in the configuration section.

You can enable CORS per action, per controller, or globally for all Web API controllers in your application:

* Add this annotation to the controller class that will be using the CORS policy. 
+
[source, c#]
----
[EnableCors("SamplePolicy")]
    public class SampleController: ControllerBase
    {
      .
      .
      .
    }
----
+
Where "SamplePolicy" is the name you give the Policy in the `appsettings.{environment}.json`.
+
The example above enables CORS for all the controller methods.

* In the same way, you may enable any CORS-policy on any controller method:
+
[source, c#]
----
[EnableCors("FirstPolicy")]
public async Task<ActionResult> GetSample()
{

}
        
public async Task<ActionResult> Modify(SampleDto sampleDto)
{

} 

[EnableCors("SecondPolicy")]        
public async Task<ActionResult> Delete([Required]long sampleId)
{

}
----
+
The example above enables CORS for the GetSample and Delete method. 

=== Tips

* If you specify the CORS in the `appsettings.{environment}.json` configuration file as empty array, a default CORS-policy will be used with all origins enabled:

[source, json]
----
 "Cors": [], //Empty array allows all origins with the policy "CorsPolicy" 
----

WARNING: Only use this policy in development environments

This default CORS-policy is defined as "CorsPolicy," and it should be enabled on the Controller Class as a standard Policy:

[source, c#]
----
[EnableCors("CorsPolicy")] 
public IActionResult Index() {  
    return View();  
}  
----

* if you want to disable the CORS check use the following annotation on any controller method:

[source, c#]
----
[DisableCors]
public IActionResult Index() {
    return View();
}
----

* If you set the EnableCors attribute at more than one scope, the order of precedence is:

1. Action
2. Controller
3. Global

== Devon4Net.Infrastructure.JWT
"JSON Web Token (JWT) is an open standard (https://datatracker.ietf.org/doc/html/rfc7519[RFC 7519]) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the `HMAC` algorithm) or a public/private key pair using `RSA` or `ECDSA` ."
-- https://jwt.io/introduction/[What is JSON Web Token?]

In other words, a JSON Web Token is a JSON object encoded into an encrypted `string` that can be decoded and verified making use of cryptographic methods and algorithms. This tokens are mostly used to authenticate users in the context of websites, web applications and web services, but they can also be used to securely exchange information between parties.

=== Configuration
Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"JWT": {
    "Audience": "devon4Net",
    "Issuer": "devon4Net",
    "ValidateIssuerSigningKey": true,
    "ValidateLifetime": true,
    "RequireSignedTokens": true,
    "RequireExpirationTime": true,
    "RequireAudience": true,
    "ClockSkew": 5,
    "Security": {
      "SecretKeyEncryptionAlgorithm": "",
      "SecretKey": "",
      "Certificate": "",
      "CertificatePassword": "",
      "CertificateEncryptionAlgorithm": "",
      "RefreshTokenEncryptionAlgorithm": ""
    }
  },
----

In the following list all the configuration fields are described:

* `Audience`: Represents a valid audience that will be used to check against the token's audience.
* `Issuer`: Represents a valid issuer that will be used to check against the token's issuer.
//* `TokenExpirationTime`: -------
* `ValidateIssuerSigningKey`: Boolean that controls if validation of the SecurityKey that signed the securityToken is called.
* `ValidateLifetime`: Boolean to control if the lifetime will be validated during token validation.
* `RequireSignedTokens`: Boolean that indicates wether a security token has to be signed oe not.
* `RequireExpirationTime`: Boolean that tells the handler if tokens need an expiration time specified or not.
* `RequireAudience`: Boolean that indicates tokens need to have an audience specified to be valid or not.
* `ClockSkew`: Expiration time in minutes.
* `Security`: Certificate properties will be found in this part.
** `SecretKeyEncryptionAlgorithm`: Algorithm used to encrypt the secret key. If no argument is specified, `HmacSha512` is used.
** `SecretKey`: Private key used to sign with the certificates. This key will be encrypted and hashed using the specified algorithm.
** `Certificate`: Name of certificate file or its path (if it is not in the same directory). If it doesn't exist an exception will be raised.
** `CertificatePassword`: Password for the certificate selected.
** `CertificateEncryptionAlgorithm`: Algorithm used to encrypt the certificate. If no argument is specified, `HmacSha512` is used.
** `RefreshTokenEncryptionAlgorithm`: Algorithm used to encrypt the refresh token. If no argument is specified, `HmacSha512` is used.

There are two ways of using and creating tokens:

* Secret key: A key to encrypt and decrypt the tokens is specified. This key will be encrypted using the specified algorithm.
* Certificates: A certificate is used to manage token encryption and decryption.

NOTE: Because the secret key takes precedence over the other option, JWT with the secret key will be used if both configurations are supplied.

==== Encryption algorithms

The supported and tested algorithms are the following:

|=======================
|*Algorithm* |*Value*
|`HmacSha256` | HS256
|`HmacSha384` | HS384
|`HmacSha512` | HS512
|`HmacSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
|`HmacSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha384
|`HmacSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512
|=======================

For the refresh token encryption algorithm you will be able to use any algoritm from the previous table and the following table:

|=======================
|*Algorithm* |*Value*
|`MD5` | MD5
|`Sha` | SHA
|=======================

NOTE: You will need to specify the name of the algorithm (shown in 'algorithm' column) when configuring the component.

////
*RSA*
|=======================
|*Algorithm*|*Value*
|`RsaSha256` | RS256
|`RsaSha384` | RS384
|`RsaSha512` | RS512
|`RsaSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha256
|`RsaSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha384
|`RsaSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha512
|`RsaOAEP` | RS-OAEP
|`RsaPKCS1` | RSA1_5
|`RsaOaepKeyWrap` | http://www.w3.org/2001/04/xmlenc#rsa-oaep
|=======================

*ECDsa*
|=======================
|*Algorithm*|*Value*
|`EcdsaSha256` | ES256
|`EcdsaSha384` | ES384
|`EcdsaSha512` | ES512
|`EcdsaSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256
|`EcdsaSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384
|`EcdsaSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512
|=======================

*Hash*
|=======================
|*Algorithm*|*Value*
|`Sha256` | SHA256
|`Sha384` | SHA384
|`Sha512` | SHA512
|`Sha256Digest` | http://www.w3.org/2001/04/xmlenc#sha256
|`Sha384Digest` | http://www.w3.org/2001/04/xmldsig-more#sha384
|`Sha512Digest` | http://www.w3.org/2001/04/xmlenc#sha512
|=======================

*Symmetric*
|=======================
|*Algorithm*|*Value*
|`Aes128CbcHmacSha256` | A128CBC-HS256
|`Aes192CbcHmacSha384` | A192CBC-HS384
|`Aes256CbcHmacSha512` | A256CBC-HS512
|`Aes128KW` | A128KW
|`Aes256KW` | A256KW
|`HmacSha256` | HS256
|`HmacSha384` | HS384
|`HmacSha512` | HS512
|`HmacSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
|`HmacSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha384
|`HmacSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512
|=======================
////

NOTE: Please check https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms[Windows Documentation] to get the latest updates on supported encryption algorithms.

=== Setting up in devon
For setting it up using the Devon4NetApi template configure it in the `appsettings.{environment}.json` file. 

You will need to add a certificate that will be used for signing the token, please check the documentation about how to create a new certificate and add it to a project if you are not aware of how it's done.

Remember to configure your certificates in the JWT configuration.

Navigate to `Devon4Net.Application.WebAPI.Implementation.Business.AuthManagement.Controllers`. There you will find `AuthController` sample class which is responsible of generating the token thanks to login method.

[source, c#]
----
public AuthController(IJwtHandler jwtHandler)
{
    JwtHandler = jwtHandler;
}
----

You can see how the `IJwtHandler` is injected in the constructor via its interface, which allows you to use its methods.

In the following piece of code, you will find how the client token is created using a variety of claims. In this case this end-point will be available to not identified clients thanks to the `AllowAnonymous` attribute. The client will also have a sample role asigned, depending on which it will be able to access some end-points and not others. 
[source, c#]
----
[AllowAnonymous]
.
.
.
var token = JwtHandler.CreateClientToken(new List<Claim>
{
    new Claim(ClaimTypes.Role, AuthConst.DevonSampleUserRole),
    new Claim(ClaimTypes.Name,user),
    new Claim(ClaimTypes.NameIdentifier,Guid.NewGuid().ToString()),
});

return Ok(new LoginResponse { Token = token });
----

The following example will require clients to have the sample role to be able to use the end-point, thanks to the attribute `Authorize` with the `Roles` value specified. 

It also shows how you can obtain information directly from the token using the `JwtHandler` injection.
[source, c#]
----
[Authorize(AuthenticationSchemes = AuthConst.AuthenticationScheme, Roles = AuthConst.DevonSampleUserRole)]
.
.
.
//Get claims
var token = Request.Headers["Authorization"].ToString().Replace($"{AuthConst.AuthenticationScheme} ", string.Empty);
.
.
.
// Return result with claims values
var result = new CurrentUserResponse
{
    Id = JwtHandler.GetClaimValue(userClaims, ClaimTypes.NameIdentifier),
    UserName = JwtHandler.GetClaimValue(userClaims, ClaimTypes.Name),
    CorporateInfo = new List<CorporateBasicInfo> 
    { 
        new CorporateBasicInfo 
        { 
            Id = ClaimTypes.Role, 
            Value = JwtHandler.GetClaimValue(userClaims, ClaimTypes.Role) 
        } 
    }
};

return Ok(result);
----

NOTE: Please check devon documentation of Security and Roles to learn more about method attributtes.

=== Setting up in other projects
Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.JWT
----

Configure swagger in `Program.cs` adding the following lines:

[source, c#]
----
using Devon4Net.Application.WebAPI.Configuration;
.
.
.
builder.Services.SetupJwt(builder.Configuration);
----

At this moment you'll need to have at least one certificate added to your project.


NOTE: Please read the documentation of how to create and add certificates to a project.

Now we will configure the JWT component in `appsettings.{environment}.json` as shown in the next piece of code:

[source, json]
----
"JWT": {
    "Audience": "devon4Net",
    "Issuer": "devon4Net",
    "ValidateIssuerSigningKey": true,
    "ValidateLifetime": true,
    "RequireSignedTokens": true,
    "RequireExpirationTime": true,
    "RequireAudience": true,
    "ClockSkew": 5,
    "Security": {
      "SecretKeyLengthAlgorithm": "",
      "SecretKeyEncryptionAlgorithm": "",
      "SecretKey": "",
      "Certificate": "localhost.pfx",
      "CertificatePassword": "12345",
      "CertificateEncryptionAlgorithm": "HmacSha512",
      "RefreshTokenEncryptionAlgorithm": "Sha"
    }
  },
----

For using it, you will need a method that provides you a token. So lets create an `AuthController` controller and add those methods:
[source, c#]
----
[Route("api/[controller]")]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly IJwtHandler _jwtHandler;

    public AuthController(IJwtHandler jwtHandler)
    {
        _jwtHandler = jwtHandler;
    }

    [HttpGet]
    [Route("/Auth")]
    [AllowAnonymous]
    public IActionResult GetToken()
    {
        var token = _jwtHandler.CreateClientToken(new List<Claim>
        {
            new Claim(ClaimTypes.Role, "MyRole"),
            new Claim(ClaimTypes.Name, "MyName"),
            new Claim(ClaimTypes.NameIdentifier, Guid.NewGuid().ToString()),
        });
        return Ok(token);
    }

    [HttpGet]
    [Route("/Auth/CheckToken")]
    [Authorize(AuthenticationSchemes = "Bearer", Roles = "MyRole")]
    public IActionResult CheckToken()
    {
        var token = Request.Headers["Authorization"].ToString().Replace($"Bearer ", string.Empty);
        var userClaims = _jwtHandler.GetUserClaims(token).ToList();
        var result = new 
        {
            Id = _jwtHandler.GetClaimValue(userClaims, ClaimTypes.NameIdentifier),
            UserName = _jwtHandler.GetClaimValue(token, ClaimTypes.Name),
            Role = _jwtHandler.GetClaimValue(userClaims, ClaimTypes.Role)
        };
        return Ok(result);
    }
}
----
Reading the code of this controller you have to take in mind a few things:

* `IJwtHandler` class is injected via dependency injection.

** `string CreateClientToken(List<Claim> list)` will allow you to create the token through a list of claims. The claims shown are hard-coded examples.

** `List<Claim> GetUserClaims(string token)` will allow you to get a list of claims given a token.

** `string GetClaimValue(List<Claim> list, string claim)` will allow you to get the value given the ClaimType and either a list of claims or a token thanks to the `string GetClaimValue(string token, string claim)` overload.

* `[AllowAnonymous]` attribute will allow access any client without authentication.

* `[Authorize(AuthenticationSchemes = "Bearer", Roles = "MyRole")]` attribute will allow any client authenticated with a bearer token and the role `"MyRole"`.


=== References

* https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.tokens.tokenvalidationparameters?view=azure-dotnet[TokenValidationParameterClass - Microsoft Docs]

* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/[Attributtes in C# - Microsoft Docs]

* https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms[Algorithms supported]

== Devon4Net.Infrastructure.LiteDb
https://www.litedb.org/[LiteDb] is an open-source NoSQL embedded database for .NET. Is a document store inspired by MongoDB database. It stores data in documents, which are JSON objects containing key-value pairs. It uses BSON which is a Binary representation of JSON with additional type information.

One of the advantages of using this type of NoSQL database is that it allows the use of asynchronous programming techniques following ACID properties on its transactions. This properties are: Atomicity, Consistency, Isolation and Durability, and they ensure the highest possible data reliability and integrity. This means that you will be able to use `async/await` on your operations.

=== Configuration
The component configuration can be done in `appsettings.{environment}.json` with the following section:

[source, json]
----
"LiteDb": {
  "EnableLiteDb": true,
  "DatabaseLocation": "devon4net.db"
}
----

* `EnableLiteDb`: Boolean to activate the use of LiteDb.
* `DatabaseLocation`: Relative path of the file containing all the documents.

=== Setting up in devon
For setting it up using the Devon4Net WebApi template just configure it in the `appsettings.Development.json`.

Then you will need to inject the repositories. For that go to `Devon4Net.Application.WebAPI.Implementation.Configuration.DevonConfiguration` and add the folowing lines in `SetupDependencyInjection` method:

[source, c#]
----
using Devon4Net.Infrastructure.LiteDb.Repository;
.
.
.
services.AddTransient(typeof(IRepository<>), typeof(Repository<>));
----

Now you can use the `IRepository<T>` by injecting it wherever you want to use it. `T` will be the entity you will be working with in the repository.

[source, c#]
----
private readonly IRepository<Todo> _todoRepository;

public TodoController(IRepository<Todo> todoRepository)
{
    _todoRepository = todoRepository;
}
----


=== Setting up in other projects
For setting it up in other projects install it running the following command in the Package Manager Console, or using the Package Manager in Visual Studio:

[source, console]
----
install-package Devon4Net.Infrastructure.LiteDb
----

Now set the configuration in the `appsettings.{enviroment}.json`:
[source, json]
----
"LiteDb": {
  "EnableLiteDb": true,
  "DatabaseLocation": "devon_database.db"
}
----

NOTE: Remember to set `EnableLiteDb` to `true`.

Navigate to your `Program.cs` file and add the following line to configure the component:

[source, c#]
----
using Devon4Net.Application.WebAPI.Configuration;
.
.
.
builder.Services.SetupLiteDb(builder.Configuration);
----

You will need also to add the repositories you will be using to your services, either by injecting the generic:

[source, c#]
----
builder.Services.AddTransient(typeof(IRepository<>), typeof(Repository<>));
----

Or by choosing to inject them one by one:

[source, c#]
----
builder.Services.AddTransient<IRepository<WeatherForecast>, Repository<WeatherForecast>>();
----

Now you will be able to use the repositories in your class using dependency injection, for example:

[source, c#]
----
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    private readonly IRepository<WeatherForecast> _weatherForecastRepository;

    public WeatherForecastController(IRepository<WeatherForecast> weatherForecastRepository)
    {
        _weatherForecastRepository = weatherForecastRepository;
    }

    [HttpGet]
    public IEnumerable<WeatherForecast> Get()
    {
        return _weatherForecastRepository.Get();
    }

    [HttpPost]
    public IEnumerable<WeatherForecast> PostAndGetAll(WeatherForecast weatherForecast)
    {
        _weatherForecastRepository.Create(weatherForecast);
        return _weatherForecastRepository.Get();
    }
}
----

== Devon4Net.Infrastructure.Kafka
https://kafka.apache.org/[Apache Kafka] is an open-source distributed event streaming platform. Event streaming is the practice of capturing a stream of events and store it for later being able to retrieve it for processing it in the desired form. It guarantees a continuous flow of data between components in a distributed system. You can think of it as a data bus where components of a system can publish some events and can subscribe to others, the following diagram shows perfectly how the system works: 

.Kafka diagram
image::images/kafka.png[]

In the image you can see how an event is sent to the Kafka server. This *Event* is a record of an action that happened and typically contains a key, value, timestamp and some metadata.

This events are published by *Producers*, who are those client applications that write to Kafka; and readed and processed by *Consumers*, who are the clients subscribed to the different topics.

*Topics* are the organization type of Kafka events, similar to a folder on a filesystem, being events the files in that folder. Unlike message queues, Kafka events are not deleted after being read. Instead you can choose how much time should Kafka keep track of the events.

Other interesting concepts about Kafka are:

* *Partitions*: Topics are divided into partitions. When a new event is published to a topic, it is actually appended to one of the topic's partitions. Events with the same event key are written to the same partition.

* *Replication*: To make your data fault-tolerant and highly-available, every topic can be replicated so that there are always multiple brokers that have a copy of the data just in case things go wrong.

=== Configuration
The component configuration can be done in `appsettings.{environment}.json` with the following section:

[source, json]
----
"Kafka": {
    "EnableKafka": true,
    "Administration": [
      {
        "AdminId": "Admin1",
        "Servers": "127.0.0.1:9092"
      }
    ],
    "Producers": [
      {
        "ProducerId": "Producer1", 
        "Servers": "127.0.0.1:9092", 
        "ClientId": "client1", 
        "Topic": "devonfw", 
        "MessageMaxBytes": 1000000, 
        "CompressionLevel": -1, 
        "CompressionType": "None", 
        "ReceiveMessageMaxBytes": 100000000,
        "EnableSslCertificateVerification": false,
        "CancellationDelayMaxMs": 100, 
        "Ack": "None", 
        "Debug": "", 
        "BrokerAddressTtl": 1000, 
        "BatchNumMessages": 1000000, 
        "EnableIdempotence": false, 
        "MaxInFlight": 5,
        "MessageSendMaxRetries": 5,
        "BatchSize": 100000000 
      }
    ],
    "Consumers": [
      {
        "ConsumerId": "Consumer1", 
        "Servers": "127.0.0.1:9092",
        "GroupId": "group1",
        "Topics": "devonfw", 
        "AutoCommit": true,
        "StatisticsIntervalMs": 0, 
        "SessionTimeoutMs": 10000, 
        "AutoOffsetReset": "Largest", 
        "EnablePartitionEof": true,
        "IsolationLevel": "ReadCommitted", 
        "EnableSslCertificateVerification": false,
        "Debug": "" 
      }
    ]
  }
----

* `EnableKafka`: Boolean to activate the use of Apache Kafka.
* `Administration`: 
** `AdminId`: Admin Identifier
** `Servers`: Host address and port number in the form of `host:port`.
* `Producers`: List of all kafka producers configuration.
** `ProducerId`: Identifier of the producer in devon.
** `Servers`: Host address and port number in the form of `host:port`.
** `ClientId`: Identifier of the client in Kafka.
** `Topic`: Topics where the event will be delivered.
** `MessageMaxBytes`: Maximum Kafka protocol request message size. Due to differing framing overhead between protocol versions the producer is unable to reliably enforce a strict max message limit at produce time and may exceed the maximum size by one message in protocol ProduceRequests, the broker will enforce the the topic's `max.message.bytes` limit (see Apache Kafka documentation).
** `CompressionLevel`: Compression level parameter for algorithm selected by configuration property compression.codec. Higher values will result in better compression at the cost of more CPU usage. Usable range is algorithm-dependent:
+
[0-9] for gzip; [0-12] for lz4; only 0 for snappy; -1 = codec-dependent 
+
Default is `-1`.

** `CompressionType`: compression codec to use for compressing message sets. This is the default value for all topics, may be overridden by the topic configuration property compression.codec. Types are: `None`, `Gzip`, `Snappy`, `Lz4`, `Zstd`. Default is `None`.
** `ReceiveMessageMaxBytes`: Maximum Kafka protocol response message size. Default is `100000000`.
** `EnableSslCertificateVerification`: Enable OpenSSL's builtin broker (server) certificate verification. Default is `true`.
** `CancellationDelayMaxMs`: The maximum time in milliseconds before a cancellation request is acted on. Low values may result in measurably higher CPU usage. Default is `100`.
** `Ack`:
+
|====
|*Value* | *Description* 
|`None` - default | Broker does not send any response/ack to client
|`Leader` | The leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers
|`All` | Broker will block until message is committed by all in sync replicas (ISRs). If there are less than min.insync.replicas (broker configuration) in the ISR set the produce request will fail
|====
+
Default is `None`.

** `Debug`:
A comma-separated list of debug contexts to enable. Detailed Producer debugging: broker,topic,msg. Consumer: consumer,cgrp,topic,fetch
** `BrokerAddressTtl`: How long to cache the broker address resolving results in milliseconds.
** `BatchNumMessages`: Maximum size (in bytes) of all messages batched in one MessageSet, including protocol framing overhead. This limit is applied after the first message has been added to the batch, regardless of the first message's size, this is to ensure that messages that exceed `batch.size` are produced. The total MessageSet size is also limited by `batch.num.messages` and `message.max.bytes`
** `EnableIdempotence`: When set to `true`, the producer will ensure that messages are successfully produced exactly once and in the original produce order. The following configuration properties are adjusted automatically (if not modified by the user) when idempotence is enabled: `max.in.flight.requests.per.connection=5` (must be less than or equal to 5), `retries=INT32_MAX` (must be greater than 0), `acks=all`, `queuing.strategy=fifo`. Producer instantation will fail if user-supplied configuration is incompatible
** `MaxInFlight`: Maximum number of in-flight requests per broker connection. This is a generic property applied to all broker communication, however it is primarily relevant to produce requests. In particular, note that other mechanisms limit the number of outstanding consumer fetch request per broker to one. Default is `5`.
** `MessageSendMaxRetries`: How many times to retry sending a failing Message. Default is `5`.
** `BatchSize`: Maximum size (in bytes) of all messages batched in one MessageSet, including protocol framing overhead. This limit is applied after the first message has been added to the batch, regardless of the first message's size, this is to ensure that messages that exceed batch.size are produced. The total MessageSet size is also limited by batch.num.messages and `message.max.bytes`. Default is `1000000`.
* `Consumers`: List of consumers configurations.
** `ConsumerId`: Identifier of the consumer for devon.
** `Servers`: Host address and port number in the form of `host:port`.
** `GroupId`: Client group id string. All clients sharing the same group.id belong to the same group.
** `Topics`: Topics where the event will be read from.
** `AutoCommit`: Automatically and periodically commit offsets in the background. Note: setting this to false does not prevent the consumer from fetching previously committed start offsets. To circumvent this behaviour set specific start offsets per partition in the call to assign()
** `StatisticsIntervalMs`: librdkafka statistics emit interval. The application also needs to register a stats callback using `rd_kafka_conf_set_stats_cb()`. The granularity is 1000ms. A value of 0 disables statistics
** `SessionTimeoutMs`: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance. Default is `0`.
** `AutoOffsetReset`: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error which is retrieved by consuming messages and checking 'message-&gt;err'
** `EnablePartitionEof`: Verify CRC32 of consumed messages, ensuring no on-the-wire or on-disk corruption to the messages occurred. This check comes at slightly increased CPU usage
** `IsolationLevel`: Controls how to read messages written transactionally: `ReadCommitted` - only return transactional messages which have been committed. `ReadUncommitted` - return all messages, even transactional messages which have been aborted.
** `EnableSslCertificateVerification`: Enable OpenSSL's builtin broker (server) certificate verification. Default is `true`.
** `Debug`: A comma-separated list of debug contexts to enable. Detailed Producer debugging: broker,topic,msg. Consumer: consumer,cgrp,topic,fetch

=== Setting up in Devon

For setting it up using the Devon4Net WebApi template just configure it in the `appsettings.Development.json`. You can do this by copying the previously showed configuration with your desired values.

NOTE: Please refer to the "How to use Kafka" and "Kafka template" documentation to learn more about Kafka.

=== Setting up in other projects

For setting it up in other projects install it running the following command in the Package Manager Console, or using the Package Manager in Visual Studio:

[source, console]
----
install-package Devon4Net.Infrastructure.Kafka
----

This will install all the packages the component needs to work properly. Now set the configuration in the `appsettings.{enviroment}.json`:
[source, json]
----
"Kafka": {
    "EnableKafka": true,
    "Administration": [
      {
        "AdminId": "Admin1",
        "Servers": "127.0.0.1:9092"
      }
    ],
    "Producers": [
      {
        "ProducerId": "Producer1", 
        "Servers": "127.0.0.1:9092", 
        "ClientId": "client1", 
        "Topic": "devonfw", 
        "MessageMaxBytes": 1000000, 
        "CompressionLevel": -1, 
        "CompressionType": "None", 
        "ReceiveMessageMaxBytes": 100000000,
        "EnableSslCertificateVerification": false,
        "CancellationDelayMaxMs": 100, 
        "Ack": "None", 
        "Debug": "", 
        "BrokerAddressTtl": 1000, 
        "BatchNumMessages": 1000000, 
        "EnableIdempotence": false, 
        "MaxInFlight": 5,
        "MessageSendMaxRetries": 5,
        "BatchSize": 100000000 
      }
    ],
    "Consumers": [
      {
        "ConsumerId": "Consumer1", 
        "Servers": "127.0.0.1:9092",
        "GroupId": "group1",
        "Topics": "devonfw", 
        "AutoCommit": true,
        "StatisticsIntervalMs": 0, 
        "SessionTimeoutMs": 10000, 
        "AutoOffsetReset": "Largest", 
        "EnablePartitionEof": true,
        "IsolationLevel": "ReadCommitted", 
        "EnableSslCertificateVerification": false,
        "Debug": "" 
      }
    ]
  }
----

Navigate to your `Program.cs` file and add the following lines to configure the component:

[source, c#]
----
using Devon4Net.Application.WebAPI.Configuration;
.
.
.
builder.Services.SetupKafka(builder.Configuration);
----

As you will be able to tell, the process is very similar to installing other components. Doing the previous actions will allow you to use the different handlers available with kafka. You can learn more 

NOTE: Please refer to the "How to use Kafka" and "Kafka template" documentation to learn more about Kafka.

== Devon4Net.Infrastructure.Grpc

As you may know at this point in Grpc communication two parties are involved: the client and the server. The server provides an implementation of a service that the client can access. Both have access to a file that acts as a contract between them, this way each of them can be written in a different language. This file is the protocol buffer. 

To learn more you can read "Grpc Template" and "How to use Grpc" in devon documentation or forward to https://grpc.io/[gRPC official site].

=== Configuration

==== Grpc server

The server does not need any type of specific configuration options other than the certificates, headers or other components that need to be used in the same project.

==== Grpc Client
On the other hand, the client needs the following configuration on the `appsettings.{environment}.json` file:

[source, json]
----
"Grpc" : {
    "EnableGrpc": true,
    "UseDevCertificate": true,
    "GrpcServer": "https://localhost:5002",
    "MaxReceiveMessageSize": 16,
    "RetryPatternOptions": {
      "MaxAttempts": 5,
      "InitialBackoffSeconds": 1,
      "MaxBackoffSeconds": 5,
      "BackoffMultiplier": 1.5,
      "RetryableStatus": "Unavailable"
    }
}
----

* `EnableGrpc`: Boolean to enable the use of Grpc component.
* `UseDevCertificate`: Boolean to bypass validation of client certificate. Only for development purposes.
* `GrpcServer`: Grpc server host and port number in the form of `Host:Port`
* `MaxReceiveMessageSize`: Maximum size of message that can be received by the server in MB.
* `RetryPatternOptions`: Options for the retry pattern applied when communicating with the server.
** `MaxAttempts`: Maximum number of communication attempts.
** `InitialBackoffSeconds`: Initial delay time for next try in seconds. A randomized delay between 0 and the current backoff value will determine when the next retry attempt is made.
** `MaxBackoffSeconds`: Maximum time in seconds that work as an upper limit on exponential backoff growth.
** `BackoffMultiplier`: The backoff time will be multiplied by this number in its growth.
** `RetryableStatus`: Status of the requests that may be retried.
+
|===
|*Status* |*Code*
|OK |0
|Cancelled |1
|Unknown |2
|InvalidArgument |3
|DeadlineExceeded |4
|NotFound |5
|AlreadyExists |6
|PermissionDenied |7
|Unauthenticated |0x10
|ResourceExhausted |8
|FailedPrecondition |9
|Aborted |10
|OutOfRange |11
|Unimplemented |12
|Internal |13
|Unavailable |14
|DataLoss |0xF
|===

=== Setting up in Devon

==== Grpc Server

For setting up a Grpc server in a devon project you will need to first create the service that implements the contract specified in the proto file. Below an example of service is shown:

[source, c#]
----
[GrpcDevonServiceAttribute]
public class GreeterService : Greeter.GreeterBase
{
    public GreeterService() { }

    public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
    {
        return Task.FromResult(new HelloReply
        {
            Message = "Hello " + request.Name
        });
    }
}
----

This previous example of service will be extending the following protocol buffer (`.proto` file):

[source, proto]
----
syntax = "proto3";
option csharp_namespace = "Devon4Net.Application.GrpcServer.Protos";
package greet;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
----

Once you have all your services created you will need to add them as Grpc services on your server. All of the services marked with the `GrpcDevonService` attribute will be automatically added, but you need to specify the assembly names where they are implemented. For that you can modify the following lines in the `Program.cs` file:

[source, c#]
----
app.SetupGrpcServices(new List<string> { "Devon4Net.Application.GrpcServer" });
----

`SetupGrpcServices` method will accept a list of assembly names so feel free to organize your code as desired.

==== Grpc Client

In the client side, you will need to add the configuration with your own values on the `appsettings.{environment}.json` file, for that copy the configuration JSON shown in the previous part and add your own values.

Everything is ready if you are using the template. So next step will be use the GrpcChanel via dependency injection and use the service created before as shown:

[source, c#]
----
[ApiController]
[Route("[controller]")]
public class GrpcGreeterClientController : ControllerBase
{
    private GrpcChannel GrpcChannel { get; }

    public GrpcGreeterClientController(GrpcChannel grpcChannel)
    {
        GrpcChannel = grpcChannel;
    }

    [HttpGet]
    [ProducesResponseType(typeof(HelloReply), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<HelloReply> Get(string name)
    {
        try
        {
            var client = new Greeter.GreeterClient(GrpcChannel);
            return await client.SayHelloAsync(new HelloRequest { Name = name }).ResponseAsync.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Devon4NetLogger.Error(ex);
            throw;
        }
    }
}
----

=== Setting up in other projects

==== Grpc Server
For setting up a Grpc server in other projects you will need to install the component running the following command in the Package Manager Console, or using the Package Manager in Visual Studio:

[source, console]
----
install-package Devon4Net.Infrastructure.Grpc
----

This will install all the packages the component needs to work properly. Navigate to your `Program.cs` file and add the following lines to configure the component.

[source, c#]
----
using Devon4Net.Infrastructure.Grpc;
.
.
.
builder.Services.AddGrpc();
----

You will need to add the assembly names for the services you created in the following line, so they can be automatically deployed to your server: 

[source, c#]
----
app.SetupGrpcServices(new List<string> { "Devon4Net.Application.GrpcServer" });
----

NOTE: Please refer to "Grpc template" and "How to use Grpc" documentation to learn more.

==== Grpc Client

For setting up a Grpc client in other projects you will need to install the component running the following command in the Package Manager Console, or using the Package Manager in Visual Studio:

[source, console]
----
install-package Devon4Net.Infrastructure.Grpc
----

Now set the configuration in the `appsettings.{enviroment}.json` file as follows:

[source, json]
----
"Grpc" : {
    "EnableGrpc": true,
    "UseDevCertificate": true,
    "GrpcServer": "https://localhost:5002",
    "MaxReceiveMessageSize": 16,
    "RetryPatternOptions": {
      "MaxAttempts": 5,
      "InitialBackoffSeconds": 1,
      "MaxBackoffSeconds": 5,
      "BackoffMultiplier": 1.5,
      "RetryableStatus": "Unavailable"
    }
}
----

Navigate to your `Program.cs` file and add the following lines to configure the component:

[source, c#]
----
using Devon4Net.Infrastructure.Grpc;
.
.
.
builder.Services.SetupGrpc(builder.Configuration);
----

Following this steps will allow you to use `GrpcChannel` via dependency injection in your classes, so you can call any procedure through Grpc communication.

